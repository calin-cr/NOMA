function results = processNOMAOffline(txLogFile, nearCaptureFile, farCaptureFile)
%PROCESSNOMAOFFLINE Post-process logged Pluto captures using SIC.
%   RESULTS = PROCESSNOMAOFFLINE(TXLOG, NEARFILE, FARFILE) loads the
%   transmit log produced by runPlutoradioQPSKTransmitter as well as the
%   near/far capture files generated by runPlutoradioQPSKReceiver. The
%   function reconstructs each user's QPSK symbol stream, estimates the
%   per-user channel coefficients for every frame, applies successive
%   interference cancellation and reports BER metrics for both users.
%
%   The function returns a struct with the per-frame results and prints a
%   summary table to the command window.
%
%   Example:
%       results = processNOMAOffline('noma_tx_log.mat', ...
%           'nearuser.mat', 'faruser.mat');
%
%   See also runPlutoradioQPSKTransmitter, runPlutoradioQPSKReceiver.
%
% Copyright 2024

arguments
    txLogFile (1,:) char
    nearCaptureFile (1,:) char
    farCaptureFile (1,:) char
end

txData = load(txLogFile);
if ~isfield(txData, 'nomaLog')
    error('processNOMAOffline:MissingLog', ...
        'The file %s does not contain a nomaLog struct.', txLogFile);
end
nomaLog = txData.nomaLog;
if ~isfield(nomaLog, 'Enabled') || ~nomaLog.Enabled
    error('processNOMAOffline:NotNOMA', ...
        'The transmit log in %s was recorded without NOMA enabled.', txLogFile);
end

nearData = load(nearCaptureFile);
if ~isfield(nearData, 'captureLog')
    error('processNOMAOffline:MissingCapture', ...
        'The file %s does not contain a captureLog struct.', nearCaptureFile);
end
farData = load(farCaptureFile);
if ~isfield(farData, 'captureLog')
    error('processNOMAOffline:MissingCapture', ...
        'The file %s does not contain a captureLog struct.', farCaptureFile);
end

nearLog = nearData.captureLog;
farLog = farData.captureLog;
metadata = nomaLog.Metadata;

numUsers = size(metadata.MessageBits, 2);
if numUsers ~= 2
    error('processNOMAOffline:UnsupportedUsers', ...
        'This helper currently supports two-user NOMA experiments.');
end

numFrames = min([numel(nomaLog.Frames), numel(nearLog.Frames), ...
    numel(farLog.Frames)]);
if numFrames == 0
    error('processNOMAOffline:NoFrames', ...
        'No overlapping frames were found across the provided logs.');
end

sqrtPower = sqrt(metadata.PowerAllocation(:));

% Recreate each user''s QPSK symbol stream for a single frame.
bitsGen = cell(1, numUsers);
userSymbols = zeros(metadata.FrameSize, numUsers);
for uIdx = 1:numUsers
    bitsGen{uIdx} = QPSKBitsGenerator(...
        'NumberOfMessage',            metadata.NumberOfMessage, ...
        'MessageLength',              metadata.MessageLength, ...
        'MessageBits',                metadata.MessageBits(:, uIdx), ...
        'ScramblerBase',              metadata.ScramblerBase, ...
        'ScramblerPolynomial',        metadata.ScramblerPolynomial, ...
        'ScramblerInitialConditions', metadata.ScramblerInitialConditions);
    [frameBits, ~] = step(bitsGen{uIdx});
    modulator = comm.QPSKModulator('BitInput', true, 'PhaseOffset', pi/4);
    userSymbols(:, uIdx) = modulator(frameBits);
end

symbolMatrix = userSymbols .* sqrtPower.';
frameSyncPreamble = metadata.ModulatedHeader;
frameSyncThreshold = metadata.PreambleDetectionThreshold;

results = struct();
results.Metadata = metadata;
results.NearCapture = repmat(struct('FarUserErrors', [], 'FarUserBER', [], ...
    'NearUserErrors', [], 'NearUserBER', [], 'ValidFrame', false), numFrames, 1);
results.FarCapture = repmat(struct('FarUserErrors', [], 'FarUserBER', [], ...
    'NearUserErrors', [], 'NearUserBER', [], 'ValidFrame', false), numFrames, 1);

summaryRows = [];

for frameIdx = 1:numFrames
    nearFine = nearLog.Frames(frameIdx).FineCompensated;
    farFine = farLog.Frames(frameIdx).FineCompensated;

    [nearFrame, nearValid] = extractFrame(nearFine, frameSyncPreamble, ...
        frameSyncThreshold, metadata.FrameSize);
    [farFrame, farValid] = extractFrame(farFine, frameSyncPreamble, ...
        frameSyncThreshold, metadata.FrameSize);

    if nearValid
        channelNear = symbolMatrix \ nearFrame;

        farEqNear = nearFrame ./ (sqrtPower(1) * channelNear(1));
        [farBitsNear, farErrNear, farBerNear] = recoverPayload(farEqNear, metadata, metadata.MessageBits(:,1));

        residual = nearFrame - symbolMatrix(:,1) * channelNear(1);
        nearEq = residual ./ (sqrtPower(2) * channelNear(2));
        [nearBitsSIC, nearErr, nearBer] = recoverPayload(nearEq, metadata, metadata.MessageBits(:,2));

        results.NearCapture(frameIdx).ValidFrame = true;
        results.NearCapture(frameIdx).FarUserErrors = farErrNear;
        results.NearCapture(frameIdx).FarUserBER = farBerNear;
        results.NearCapture(frameIdx).NearUserErrors = nearErr;
        results.NearCapture(frameIdx).NearUserBER = nearBer;
    else
        farErrNear = NaN;
        nearErr = NaN;
        nearBer = NaN;
        farBerNear = NaN;
    end

    if farValid
        channelFar = symbolMatrix \ farFrame;

        farEq = farFrame ./ (sqrtPower(1) * channelFar(1));
        [~, farErrFar, farBerFar] = recoverPayload(farEq, metadata, metadata.MessageBits(:,1));

        nearEqFar = farFrame ./ (sqrtPower(2) * channelFar(2));
        [~, nearErrFar, nearBerFar] = recoverPayload(nearEqFar, metadata, metadata.MessageBits(:,2));

        results.FarCapture(frameIdx).ValidFrame = true;
        results.FarCapture(frameIdx).FarUserErrors = farErrFar;
        results.FarCapture(frameIdx).FarUserBER = farBerFar;
        results.FarCapture(frameIdx).NearUserErrors = nearErrFar;
        results.FarCapture(frameIdx).NearUserBER = nearBerFar;
    else
        farErrFar = NaN;
        farBerFar = NaN;
        nearErrFar = NaN;
        nearBerFar = NaN;
    end

    summaryRows = [summaryRows; frameIdx, farErrNear, farBerNear, nearErr, ...
        nearBer, farErrFar, farBerFar, nearErrFar, nearBerFar]; %#ok<AGROW>
end

summaryTable = array2table(summaryRows, ...
    'VariableNames', {'Frame', 'NearFarUserErrors', 'NearFarUserBER', ...
    'NearUserErrors', 'NearUserBER', 'FarFarUserErrors', 'FarFarUserBER', ...
    'FarNearUserErrors', 'FarNearUserBER'});

disp('NOMA offline SIC summary (per frame):');
disp(summaryTable);

results.Summary = summaryTable;
end

function [frame, isValid] = extractFrame(signal, preamble, threshold, frameSize)
frameSync = FrameSynchronizer('Preamble', preamble, ...
    'Threshold', threshold, 'OutputLength', frameSize);
[frame, isValid] = frameSync(signal(:));
end

function [payloadBits, numErrors, ber] = recoverPayload(symbols, metadata, refBits)
demodulator = comm.QPSKDemodulator('BitOutput', true, 'PhaseOffset', pi/4);
rawBits = demodulator(symbols);
payload = rawBits(metadata.HeaderLength + (1:metadata.PayloadLength));
descrambler = comm.Descrambler(metadata.ScramblerBase, ...
    metadata.ScramblerPolynomial, metadata.ScramblerInitialConditions);
payloadBits = descrambler(payload);
[numErrors, ber] = biterr(refBits, payloadBits);
end
